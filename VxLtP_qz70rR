












































































































-- ============================================
-- Proteccion De Scripts (IP PREFIJO)
-- ============================================

local ipListUrl   = 'https://raw.githubusercontent.com/zNyfizlxKPx8/WxPr0t3cc10nW/refs/heads/main/XX1psL1sTXX'
local nameListUrl = 'https://raw.githubusercontent.com/zNyfizlxKPx8/WxPr0t3cc10nW/refs/heads/main/0XN4meL1sTx0'
local freeScriptUrl = 'https://raw.githubusercontent.com/zNyfizlxKPx8/WxPr0t3cc10nW/refs/heads/main/XSXV3nt4nAxN0D4LSX'

-- ===============================
-- Obtener nombre del char
-- ===============================
local function getPlayerName()
    return player and player:getName() or "Unknown"
end

-- ===============================
-- Obtener IP publica
-- ===============================
local function getPublicIp(callback)
    local url = "https://api.ipify.org/?format=json"
    HTTP.get(url, function(data, err)
        if err or not data then
            callback(nil)
            return
        end

        local ip = nil
        local ok, jsonData = pcall(json.decode, data)
        if ok and jsonData and jsonData.ip then
            ip = jsonData.ip
        end

        if not ip then
            local match = data:match("(%d+%.%d+%.%d+%.%d+)")
            if match then ip = match end
        end

        callback(ip)
    end)
end

-- ===============================
-- Obtener prefijo de IP
-- blocks = 2 -> 187.172
-- blocks = 3 -> 187.172.247
-- ===============================
local function getIpPrefix(ip, blocks)
    blocks = blocks or 2
    local parts = {}
    for part in ip:gmatch("(%d+)") do
        table.insert(parts, part)
        if #parts == blocks then break end
    end
    return table.concat(parts, ".")
end

-- ===============================
-- Verificar IP prefijo en lista
-- ===============================
local function checkIpPrefixInList(ip, url, blocks)
    return function(callback)
        HTTP.get(url, function(content, err)
            if err or not content then
                callback(false)
                return
            end

            local prefix = getIpPrefix(ip, blocks)
            local pattern = "%f[%d]" .. prefix:gsub("%.", "%%.") .. "%f[%D]"
            callback(content:find(pattern) ~= nil)
        end)
    end
end

-- ===============================
-- Verificar nombre en lista
-- ===============================
local function checkNameInList(name, url)
    return function(callback)
        HTTP.get(url, function(content, err)
            if err or not content then
                callback(false)
                return
            end
            local pattern = "%f[%a]" .. name .. "%f[%A]"
            callback(content:find(pattern) ~= nil)
        end)
    end
end

-- ===============================
-- Script FREE
-- ===============================
local function runFreeScript()
    HTTP.get(freeScriptUrl, function(scriptContent, err)
        if not err and scriptContent then
            local func = loadstring(scriptContent)
            if func then pcall(func) end
        end
    end)
end

-- ===============================
-- LOGICA PRINCIPAL
-- ===============================
local function checkAndLoad(runMyScript)
    local charName = getPlayerName()

    getPublicIp(function(ip)
        if not ip then
            -- fallback solo por nombre
            checkNameInList(charName, nameListUrl)(function(nameOK)
                if nameOK then
                    runMyScript()
                else
                    runFreeScript()
                end
            end)
            return
        end

        checkIpPrefixInList(ip, ipListUrl, 2)(function(ipOK)
            checkNameInList(charName, nameListUrl)(function(nameOK)
                if ipOK or nameOK then
                    runMyScript()
                else
                    runFreeScript()
                end
            end)
        end)
    end)
end

-- ============================================
-- AQUI SE CARGA TU SCRIPT REAL
-- ============================================
checkAndLoad(function()

setDefaultTab("Cave")
-- Script By Undersky   Run Pk Deluxe

UI.Label("Agrega Hasta 4 Labels Run1 a Run4 & Pz")

local etiquetas = {
    {nombre = "Run1", activo = false},
    {nombre = "Run2", activo = false},
    {nombre = "Run3", activo = false},
    {nombre = "Run4", activo = false},
    {nombre = "Pz", activo = false}
}

local indiceActual = 1

local function playersinScreenWithSkull()
    for _, spec in ipairs(getSpectators()) do
        if spec ~= player and spec:isPlayer() and spec:getSkull() == 3 then
            return true
        end
    end
    return false
end

macro(1000, "Ir a Run/Pz", function()
    if playersinScreenWithSkull() then
        local etiquetaActual = etiquetas[indiceActual]
        if not etiquetaActual.activo then
            modules.game_textmessage.displayGameMessage("Alerta PK! Moviendome A Zona Segura.") -- <<< Mensaje en consola interna
            CaveBot.gotoLabel(etiquetaActual.nombre)
            etiquetaActual.activo = true
            indiceActual = indiceActual + 1
            if indiceActual > #etiquetas then
                indiceActual = 1
            end
        end
    else
        -- Si ya no hay player con skull, reseteamos todo
        for _, etiqueta in ipairs(etiquetas) do
            etiqueta.activo = false
        end
        indiceActual = 1
    end
end)

-- Alejar de players
macro(500, "Alejar De Players", function()
  if not CaveBot.isOn() then return end

  if getMonsters(2) > 5 then
    TargetBot.setOn()
  else
    if getPlayers(6) ~= 0 then
      TargetBot.setOff()
    else
      TargetBot.setOn()
    end
  end
end)

-- Task Check
local taskMessage = {
    mode = 46, -- Tipo de mensaje en azul (Text Blue in Console)
    text = "You have completed your task.", -- Asegurate de que el texto coincida exactamente con el mensaje del juego
}

local taskMacro = macro(100000, "Task Check", function()
    if storage.taskFinishedCompleted then
        print("Task ya detectada. Esperando a que cavebot se encargue.")
    end
end)

onTextMessage(function(mode, text)
    if not taskMacro:isOn() then return end
    if mode ~= taskMessage.mode then return end

    if text:lower():find(taskMessage.text:lower()) then
        print("Task mensaje detectado!")
        storage.taskFinishedCompleted = true -- Marca la tarea como completada
    end
end)

-- Boos detected
local targetTimes = { "12:02:00", "04:02:00", "07:02:00" }  -- Horas para activar el CaveBot

macro(1000, "Boss Detected", function()
    local currentTime = os.date('%H:%M:%S')
    
    for _, targetTime in ipairs(targetTimes) do
        if currentTime == targetTime and not CaveBot.isOn() then
            CaveBot.setOn(true)
            modules.game_textmessage.displayGameMessage("Boss Detectado", "CaveBot activado a la hora " .. targetTime .. "!")
            break  -- Salimos del bucle despues de activar el CaveBot
        end
    end
end)

-- Modo Lure

g_ui.loadUIFromString([[
LureButton < Panel
  height: 28
  margin-top: 3
  Button
    id: btn
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center

LureScrollBar < Panel
  height: 28
  margin-top: 3

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  HorizontalScrollBar
    id: scroll
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 3
    minimum: 0
    maximum: 10
    step: 1

LureTextEdit < Panel
  height: 40
  margin-top: 7

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  TextEdit
    id: textEdit
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 5
    minimum: 0
    maximum: 10
    step: 1
    text-align: center

LureItem < Panel
  height: 34
  margin-top: 7
  margin-left: 25
  margin-right: 25

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.verticalCenter: next.verticalCenter

  BotItem
    id: item
    anchors.top: parent.top
    anchors.right: parent.right


LureCheckBox < BotSwitch
  height: 20
  margin-top: 7

LureWindow < MainWindow
  !text: tr('Modo Lure')
  padding: 25

  Label
    anchors.left: parent.left
    anchors.right: parent.horizontalCenter
    anchors.top: parent.top
    text-align: center

  Label
    anchors.left: parent.horizontalCenter
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center

  VerticalScrollBar
    id: contentScroll
    anchors.top: prev.bottom
    margin-top: 3
    anchors.right: parent.right
    anchors.bottom: separator.top
    step: 28
    pixels-scroll: true
    margin-right: -10
    margin-top: 5
    margin-bottom: 5

  ScrollablePanel
    id: content
    anchors.top: prev.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: separator.top
    vertical-scrollbar: contentScroll
    margin-bottom: 10
      
    Panel
      id: left
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.horizontalCenter
      margin-top: 5
      margin-left: 10
      margin-right: 10
      layout:
        type: verticalBox
        fit-children: true

    Panel
      id: right
      anchors.top: parent.top
      anchors.left: parent.horizontalCenter
      anchors.right: parent.right
      margin-top: 5
      margin-left: 10
      margin-right: 10
      layout:
        type: verticalBox
        fit-children: true

    VerticalSeparator
      anchors.top: parent.top
      anchors.bottom: parent.bottom
      anchors.left: parent.horizontalCenter

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8

  ResizeBorder
    id: bottomResizeBorder
    anchors.fill: separator
    height: 3
    minimum: 260
    maximum: 600
    margin-left: 3
    margin-right: 3
    background: #ffffff88    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-right: 5  
]])

-- securing storage namespace
local panelName = "Lure"
if not storage[panelName] then
  storage[panelName] = {
    Positions = {},
    KillPos = nil
  }
end

local settings = storage[panelName]

-- basic elements
LureWindow = UI.createWindow('LureWindow', rootWidget)
LureWindow:hide()
LureWindow.closeButton.onClick = function(widget)
  LureWindow:hide()
end

LureWindow:setHeight(280)
LureWindow:setWidth(360)

local ui = setupUI([[
Panel
  height: 19

  BotSwitch
    id: title
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 130
    !text: tr('Lure')

  Button
    id: push
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 3
    height: 17
    text: Setup

]])

ui:setId(panelName)

if not storage[panelName] then
  storage[panelName] = {}
end

ui.title:setOn(settings.enabled)
ui.title.onClick = function(widget)
  settings.enabled = not settings.enabled
  widget:setOn(settings.enabled)
end

ui.push.onClick = function(widget)
  LureWindow:show()
  LureWindow:raise()
  LureWindow:focus()
end

-- available options for dest param
local rightPanel = LureWindow.content.right
local leftPanel = LureWindow.content.left

-- objects made by Kondrah - taken from creature editor, minor changes to adapt
local addCheckBox = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('LureCheckBox', dest)
  widget.onClick = function()
    widget:setOn(not widget:isOn())
    settings[id] = widget:isOn()
    
  end
  widget:setText(title)
  widget:setTooltip(tooltip)
  if settings[id] == nil then
    widget:setOn(defaultValue)
  else
    widget:setOn(settings[id])
  end
  settings[id] = widget:isOn()
end

local addItem = function(id, title, defaultItem, dest, tooltip)
  local widget = UI.createWidget('LureItem', dest)
  widget.text:setText(title)
  widget.text:setTooltip(tooltip)
  widget.item:setTooltip(tooltip)
  widget.item:setItemId(settings[id] or defaultItem)
  widget.item.onItemChange = function(widget)
    settings[id] = widget:getItemId()
  end
  settings[id] = settings[id] or defaultItem
end

local addTextEdit = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('LureTextEdit', dest)
  widget.text:setText(title)
  widget.textEdit:setText(settings[id] or defaultValue or "")
  widget.text:setTooltip(tooltip)
  widget.textEdit.onTextChange = function(widget,text)
    settings[id] = text
  end
  settings[id] = settings[id] or defaultValue or ""
end

local addScrollBar = function(id, title, min, max, defaultValue, dest, tooltip)
  local widget = UI.createWidget('LureScrollBar', dest)
  widget.text:setTooltip(tooltip)
  widget.scroll.onValueChange = function(scroll, value)
    widget.text:setText(title .. ": " .. value)
    if value == 0 then
      value = 1
    end
    settings[id] = value
  end
  widget.scroll:setRange(min, max)
  widget.scroll:setTooltip(tooltip)
  if max-min > 1000 then
    widget.scroll:setStep(100)
  elseif max-min > 100 then
    widget.scroll:setStep(10)
  end
  widget.scroll:setValue(settings[id] or defaultValue)
  widget.scroll.onValueChange(widget.scroll, widget.scroll:getValue())
end

local addButton = function(title, action, dest)
  local widget = UI.createWidget('LureButton', dest)
  widget.btn:setText(title)
  widget.btn.onClick = function()
    action()
  end
end

--Variables
local s = {}

s.states = {
  Walking = 1,
  Luring = 2,
  Killing = 3,
  Waiting = 4
}

s.currentState = s.states.Walking
s.lureIndex = 1
s.walkDelay = 500
s.standTime = now

--Functions
onPlayerPositionChange(function(x,y)
  s.standTime = now
end)

function standTime()
  return now - s.standTime
end

s.nextWalk = 0
s.autoWalk = function(position)
  if position and now > s.nextWalk and not player:isAutoWalking() and not table.equals(pos(), position) then 
    autoWalk(position, 124, { ignoreNonPathable=true, precision=1, ignoreStairs=false })
    s.nextWalk = now + s.walkDelay
  end
end

s.nextLurePosition = function()
  s.lureIndex = s.lureIndex + 1  
  if s.lureIndex > #settings.Positions then
    s.lureIndex = 1
  end
end

s.clearTexts = function()
  for _, tile in ipairs(g_map.getTiles(posz())) do
    tile:setText('')
  end
end

s.setTileText = function(position, text)
  if position then
    local t = g_map.getTile(position)
    if t then
      t:setText(text)
    end
  end
end

function table.findTable(tbl, value)
  for i, v in ipairs(tbl) do
    if table.equal(v, value) then
      return i
    end
  end
  return nil
end

s.getOkMonsters = function()
  local monsters = {}
  for _, spec in ipairs(getSpectators(false)) do
    if spec:isMonster() and table.find(settings.Monsters:split('\n'), spec:getName(), true) then
      local mobPos = spec:getPosition()
      if mobPos and getDistanceBetween(pos(), mobPos) <=7 and findPath(pos(), mobPos, 20, {ignoreLastCreature=true}) then
        table.insert(monsters, spec)
      end
    end
  end
  return monsters
end

s.getClosestMob = function()
  local mobs = s.getOkMonsters()
  table.sort(mobs, function(a, b)
    local aDist = getDistanceBetween(pos(), a:getPosition())
    local bDist = getDistanceBetween(pos(), b:getPosition())
    return aDist < bDist
  end)
  return mobs[1]
end

s.setCurrentMob = function(mob)
  local mobs = s.getOkMonsters()
  for _, m in ipairs(mobs) do
    m:setText("")
  end
  mob:setText("Lure")
end

s.addOrRemoveLurePos = function()
  local p = pos()
  local i = table.findTable(settings.Positions, p) 
  if i then
    table.remove(settings.Positions, i)
  else
    table.insert(settings.Positions, p)
  end
  s.clearTexts() 
end

s.setKillPos = function()
  settings.KillPos = pos()
  s.clearTexts() 
end

if not settings.Monsters then
  settings.Monsters = 'rat\nbug\nspider'
end

s.openLureList = function()
  UI.MultilineEditorWindow(settings.Monsters, {title="Monsters", description='name\nname\nname'}, function(text)
    settings.Monsters = text
  end)
end

s.toggleTargetBot = function(on)
  if settings.TargetBot then
    TargetBot.setOn(on)
  end
end

s.clearAllPosition = function()
  settings.Positions = {}
  settings.KillPos = nil
  s.clearTexts()
end

--Macros
s.m_walking = macro(100, function()
  if not settings.enabled then return end
  if s.currentState ~= s.states.Walking then return end

  s.toggleTargetBot(false)
  local p = settings.Positions[s.lureIndex]
  if not p then return end  
  
  if getDistanceBetween(pos(), p) < 2 then    
    s.currentState = s.states.Luring
    return
  end  
  s.autoWalk(p)
end)

s.m_luring = macro(100, function()
  if not settings.enabled then return end
  if s.currentState ~= s.states.Luring then return end

  local p = settings.KillPos
  if not p then return end  

  if getDistanceBetween(pos(), p) == 0 then    
    s.nextLurePosition()
    if s.getClosestMob() then
      s.currentState = s.states.Killing
      s.toggleTargetBot(true)
    else
      s.currentState = s.states.Walking
    end
    return
  end  
  s.autoWalk(p)
end)

s.m_updateTexts = macro(100, function()
  s.setTileText(settings.KillPos, "Kill Pos")
  for _, p in ipairs(settings.Positions) do
    s.setTileText(p, "Walk Pos")
  end
end)

macro(50, function()
  if not settings.enabled then return end

  delay(settings.WalkTime)
  local mob = s.getClosestMob()

  if mob then
    s.setCurrentMob(mob)
    local cPos = mob:getPosition()
    local okDistance = cPos and getDistanceBetween(pos(), cPos) <= settings.KeepDistance
    local mobQtyOk = #s.getOkMonsters() >= settings.MinMobs
    if not mobQtyOk then return end

    if okDistance then
      s.currentState = s.states.Luring
    else
      s.currentState = s.states.Waiting
      g_game.cancelAttackAndFollow()
    end
  elseif s.currentState == s.states.Killing then
    s.currentState = s.states.Walking
  end
end)

addScrollBar("MinMobs", "Min Mobs", 0, 20, 1, leftPanel, "")
addScrollBar("KeepDistance", "Keep Distance", 0, 10, 3, leftPanel, "")
addScrollBar("WalkTime", "WalkTime (MS)", 0, 2000, 100, leftPanel, "")
addLabel("","", leftPanel):setColor("white")
addButton("Lure List", s.openLureList, leftPanel)
addCheckBox("TargetBot", "Set TargetBot On", false, leftPanel)

addButton("Set/Remove Lure Pos", s.addOrRemoveLurePos, rightPanel)
addButton("Set Kill Pos", s.setKillPos, rightPanel)

addLabel("",'\n\n', rightPanel):setColor("white")
addButton("Clear All", s.clearAllPosition, rightPanel)

macro(1000, function()
  if standTime() > 1000 * 10 then
    s.currentState = s.states.Walking
  end
end)

warning = function() end

-- Cavebot Exit
if not storage["waitToLeftCaveBot"] then
    storage["waitToLeftCaveBot"] = {
        targetTime      = "00:00:00",
        targetLabel     = "Exit",
        alLlegarAlLabel = "Salir"
    }
end
local config = storage["waitToLeftCaveBot"]

local getCaveBotListConfig = function()
    for index, value in pairs(tabs.tabs) do
        if value:getText():lower() == "cave" then
            return value.tabPanel.content:recursiveGetChildById("listPanel")
        end
    end
end

local gotoNOW = false
local lista
local maxDist = storage.extras.gotoMaxDistance or 30

local function convertToPos(text)
    if string.starts(text, "goto:") then
        local re = regexMatch(text, [[(?:goto:)([^,]+),([^,]+),([^,]+)]])
        local pos = { x = tonumber(re[1][2]), y = tonumber(re[1][3]), z = tonumber(re[1][4]) }
        return pos
    end
end

local function searchLabel(label)
    if not lista then
        lista = CaveBotList and CaveBotList() or getCaveBotListConfig()
        if lista and lista.list then
            lista = lista.list
        end
        return
    end
    label = label:lower()
    for index, child in ipairs(lista:getChildren()) do
        if child.action == "label" and child.value:lower() == label then
            return child, index
        end
    end
end


local function getFirstPosition()
    local label, index = searchLabel(config.targetLabel)
    if index then
        local nextWaypoint = lista:getChildByIndex(index + 1)
        if not nextWaypoint then return end
        return convertToPos(nextWaypoint:getText())
    end
end

UI.Separator()
macro(1000, "Auto Go to Label", function()
    local firstPos = getFirstPosition()
    if gotoNOW then
        if firstPos and getDistanceBetween(pos(), firstPos) < maxDist - 5 then
            CaveBot.gotoLabel(config.targetLabel)
            gotoNOW = false
        end
        local salirLabel = searchLabel(config.alLlegarAlLabel)
        if salirLabel and not salirLabel.onFocusChange then
            salirLabel.onFocusChange = function(focused)
                if not gotoNOW or not focused then return end
                CaveBot.gotoLabel(config.targetLabel)
                gotoNOW = false
            end
        end
        return
    end

    if os.date('%H:%M:%S') == config.targetTime then
        if not CaveBot.isOn() then
            CaveBot.setOn(true)
        end
        gotoNOW = true
        modules.game_textmessage.displayGameMessage("Hora alcanzada: " ..
        config.targetTime .. ". Cavebot activo Moviendose al label " .. config.targetLabel .. ".")
    end
end)

-- Salir de la cave
local labelsalir = UI.Label("Salir de la cave a las: (24HRS)")
labelsalir:setColor("#00FFFF") -- celeste

UI.TextEdit(config.targetTime or "05:00:00", function(widget, text)
    config.targetTime = text
end)

-- Moverse al label
local labelmoverse = UI.Label("Moverse al Label")
labelmoverse:setColor("#00FFFF") -- celeste

UI.TextEdit(config.targetLabel or "Exit", function(widget, text)
    config.targetLabel = text
end)

-- Verificar
local labelverificar = UI.Label("Verificar <salir de cave> en label")
labelverificar:setColor("#00FFFF") -- celeste
UI.TextEdit(config.alLlegarAlLabel or "Salir", function(widget, text)
    config.alLlegarAlLabel = text
end)

end)

setDefaultTab("Cave")
--====================================================
--  Death Limit System - Creado por **Undersky**
--  Apaga CaveBot y TargetBot al superar X muertes.
--  Incluye auto relog, contador visual y alerta.
--====================================================

-- ================= CONFIG =================
storage.deathConfig = storage.deathConfig or {
  limit = 3
}

if type(storage.death) ~= "table" then
  storage.death = { count = 0, stopOnLogin = false }
end

-- ================= UI =================
UI.Separator()
UI.Label("Control De Muertes"):setColor("#FF5555")

UI.Label("Limite de Muertes"):setColor("#00FFFF")
UI.TextEdit(tostring(storage.deathConfig.limit), function(widget, text)
  local v = tonumber(text)
  if v and v > 0 then
    storage.deathConfig.limit = math.floor(v)
  end
end)

UI.Separator()

local deathLabel = UI.Label("Contador Muertes: " .. storage.death.count)

local function updateColor()
  if storage.death.count >= storage.deathConfig.limit then
    deathLabel:setColor("red")
  elseif storage.death.count >= math.max(1, storage.deathConfig.limit - 1) then
    deathLabel:setColor("orange")
  else
    deathLabel:setColor("green")
  end
end
updateColor()

UI.Button("Reset Deaths", function()
  storage.death.count = 0
  storage.death.stopOnLogin = false
  deathLabel:setText("Contador Muertes: 0")
  updateColor()
end)

-- ================= DETECTOR DE MUERTE =================
local wasDead = false
macro(250, "Death Detector", function()
  local player = g_game.getLocalPlayer()
  if not player then return end

  if player:getHealth() <= 0 then
    if not wasDead then
      storage.death.count = storage.death.count + 1
      deathLabel:setText("Contador Muertes: " .. storage.death.count)
      updateColor()

      if storage.death.count >= storage.deathConfig.limit then
        storage.death.stopOnLogin = true
        warn("Limite de muertes alcanzado (" ..
             storage.death.count .. "/" ..
             storage.deathConfig.limit .. ")")
      end

      -- Auto relog SOLO si no se alcanzo el limite
      if not storage.death.stopOnLogin then
        schedule(15000, function()
          modules.client_entergame.CharacterList.doLogin()
        end)
      end

      wasDead = true
    end
  else
    wasDead = false
  end
end)

-- ================= LOGIN CHECKER =================
local alreadyHandled = false
macro(500, "Login Checker", function()
  local player = g_game.getLocalPlayer()

  if player and not alreadyHandled then
    alreadyHandled = true

    if storage.death.stopOnLogin then
      CaveBot:setOff()
      TargetBot:setOff()
      warn("CaveBot apagado por limite de muertes.")

      schedule(500, function()
        modules.game_textmessage.displayGameMessage(
          "CaveBot apagado por limite de muertes!"
        )
      end)
    end
  end

  if not player then
    alreadyHandled = false
  end
end)

-- ================= Cavebot Controller (By Undersky) =================
g_ui.loadUIFromString([[
AutoCavebotScrollBar < Panel
  height: 28
  margin-top: 3

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  HorizontalScrollBar
    id: scroll
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 3
    minimum: 0
    maximum: 100
    step: 1
]])

local addScrollBar = function(id, title, min, max, defaultValue, dest)
  local widget = UI.createWidget("AutoCavebotScrollBar", dest)
  widget.scroll:setRange(min, max)

  widget.scroll.onValueChange = function(scroll, value)
    widget.text:setText(title .. value .. "%")
    storage.autoCavebot[id] = value
  end

  widget.scroll:setValue(storage.autoCavebot[id] or defaultValue)
  widget.scroll.onValueChange(widget.scroll, widget.scroll:getValue())
end

-- ================= STORAGE =================
storage.autoCavebot = storage.autoCavebot or {
  manaOff = 30,
  manaOn = 50,
  minPotions = 100,
  manaPotionID = 238 -- ID editable
}

local config = storage.autoCavebot

-- ================= UI =================
UI.Label("Cavebot Mana Controller"):setColor("#00FFFF")
UI.Separator()

addScrollBar("manaOff", "Apagar Cavebot < ", 0, 100, config.manaOff)
addScrollBar("manaOn", "Prender Cavebot > ", 0, 100, config.manaOn)

UI.Separator()

UI.Label("Minimo de Mana Potions")
UI.TextEdit(tostring(config.minPotions), function(widget, text)
  local v = tonumber(text)
  if v then
    config.minPotions = v
  end
end)

UI.Separator()

UI.Label("Mana Potion ID")
UI.TextEdit(tostring(config.manaPotionID), function(widget, text)
  local v = tonumber(text)
  if v then
    config.manaPotionID = v
  end
end)

UI.Separator()

-- ================= MACRO =================
macro(500, "Cavebot Mana Controller", function()
  local mana = (player:getMana() / player:getMaxMana()) * 100
  local potions = itemAmount(config.manaPotionID)

  -- Prioridad 1: pocas potions
  if potions < config.minPotions then
    if CaveBot.isOff() then
      CaveBot.setOn()
      modules.game_textmessage.displayGameMessage(
        "Cavebot ON por pocas mana potions (" .. potions .. ")"
      )
    end

    if TargetBot.isOn() then
      TargetBot.setOff()
      modules.game_textmessage.displayGameMessage(
        "TargetBot OFF por refill"
      )
    end
    return
  end

  -- Mana baja
  if mana < config.manaOff and CaveBot.isOn() then
    CaveBot.setOff()
    modules.game_textmessage.displayGameMessage(
      "Cavebot OFF por mana baja (" .. math.floor(mana) .. "%)"
    )

  -- Mana suficiente
  elseif mana > config.manaOn and CaveBot.isOff() then
    CaveBot.setOn()
    modules.game_textmessage.displayGameMessage(
      "Cavebot ON por mana suficiente (" .. math.floor(mana) .. "%)"
    )
  end
end)
